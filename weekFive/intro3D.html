<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title></title>
    <style type="text/css">
        h1 {
            text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <h1>Karol Uciecha</h1>
    <script type="text/javascript">

        // Scene creation
        const scene = new THREE.Scene();

        // Create renderer and set size to full window size
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadow mapping
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use soft shadows for smoother results
        document.body.appendChild(renderer.domElement);

        // Create camera: fov 80, aspect ratio window size, near/far clipping planes
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 50);
        camera.lookAt(0, 0, 0);

        // ===== SPHERE CLASS =====
        class Sphere {
            constructor(radius, color, startX, startY) {
                this.radius = radius;
                // Create geometry, material, and mesh for the sphere
                this.geometry = new THREE.SphereGeometry(radius, 32, 32);
                this.material = new THREE.MeshLambertMaterial({ color: color });
                this.mesh = new THREE.Mesh(this.geometry, this.material);

                // Enable shadows
                this.mesh.castShadow = true;

                // Initial position of the sphere
                this.mesh.position.set(startX, startY, 0);

                // Physics
                this.velocityY = -0.5 - Math.random() * 0.5; // current vertical velocity
                this.gravity = -0.01; // downward acceleration
                this.bounceFactor = 0.9; // energy retained after bounce
                this.rotationSpeed = 0.02; // base rotation speed
                this.minVelocity = 0.002; // threshold below which motion stops
                this.isMoving = true;
            }

            // Method to add the sphere to the scene
            addToScene(scene) {
                scene.add(this.mesh);
            }

            // Method to update the sphere's position and rotation
            move() {
                if (!this.isMoving) return;

                // Apply gravity
                this.velocityY += this.gravity;
                this.mesh.position.y += this.velocityY;

                // Bounce when hitting the plane
                const floorY = plane.position.y + this.radius;
                if (this.mesh.position.y <= floorY) {
                    this.mesh.position.y = floorY;
                    this.velocityY = -this.velocityY * this.bounceFactor;
                    this.rotationSpeed *= this.bounceFactor;
                }

                // Apply rotation (slows over time)
                this.mesh.rotation.x += this.rotationSpeed;
                this.mesh.rotation.y += this.rotationSpeed;

                // Stop motion when velocity & rotation are very small
                if (Math.abs(this.velocityY) < this.minVelocity && this.mesh.position.y <= floorY + 0.001) {
                    this.isMoving = false;
                    this.velocityY = 0;
                    this.rotationSpeed = 0;
                }
            }
            // Detect and handle collision with another sphere
            checkCollision(other) {
                const posA = this.mesh.position;
                const posB = other.mesh.position;
                const dist = posA.distanceTo(posB);
                const minDist = this.radius + other.radius;

                if (dist < minDist) {
                    // Simple elastic collision effect: reverse velocities
                    const overlap = (minDist - dist) / 2;

                    // Move both spheres apart along Y-axis for simplicity
                    if (posA.y > posB.y) {
                        posA.y += overlap;
                        posB.y -= overlap;
                    } else {
                        posA.y -= overlap;
                        posB.y += overlap;
                    }

                    // Exchange or reverse vertical velocities
                    const tempVel = this.velocityY;
                    this.velocityY = -other.velocityY * this.bounceFactor;
                    other.velocityY = -tempVel * other.bounceFactor;
                }
            }
        }

        // Create a new Spheres and add them to the scene
        const spheres = [
            new Sphere(5, 0xffff00, -25, 15),
            new Sphere(5, 0x00ffcc, 25, 30)
        ];

        spheres.forEach(s => s.addToScene(scene));

        // ===== PLANE (GROUND) =====
        const planeGeometry = new THREE.PlaneGeometry(200, 200);
        const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x999999, shininess: 30 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = - Math.PI / 2; // Rotate plane to be horizontal
        plane.position.y = -25; // Move it below the sphere
        plane.receiveShadow = true; // Enable the plane to receive shadows
        scene.add(plane);

        // ===== LIGHTING =====
        var spotLight = new THREE.SpotLight(0xffffff, 1.2);
        spotLight.position.set(30, 60, 25);
        spotLight.castShadow = true; // Enable the spotlight to cast shadows
        scene.add(spotLight);

        // Add a helper to visualize the camera's position
        const cameraHelper = new THREE.CameraHelper(spotLight.shadow.camera);
        scene.add(cameraHelper);

        // Optionally add an ambient light to prevent dark shadows
        var ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
        scene.add(ambientLight);

        // ===== ANIMATION LOOP =====
        function repeatMe() {
            // Move each sphere
            spheres.forEach(s => s.move());

            // Collision check between all pairs
            for (let i = 0; i < spheres.length; i++) {
                for (let j = i + 1; j < spheres.length; j++) {
                    spheres[i].checkCollision(spheres[j]);
                }
            }

            // Render the scene from the perspective of the camera
            renderer.render(scene, camera);

            // Call repeatMe again on the next frame
            requestAnimationFrame(repeatMe);
        }

        // Start the animation loop
        repeatMe();

        // Optional: Handle resizing so the canvas adjusts when window size changes
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>