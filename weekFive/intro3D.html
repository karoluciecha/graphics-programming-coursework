<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title></title>
    <style type="text/css">
        h1 {
            text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <h1>Karol Uciecha</h1>
    <script type="text/javascript">

        // Scene creation
        var scene = new THREE.Scene();

        // Class to encapsulate the sphere and its properties
        class Sphere {
            constructor(radius, widthSegments, heightSegments, color) {

                // Create geometry and material
                this.geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
                this.material = new THREE.MeshLambertMaterial({ color: color });

                // Create mesh (sphere)
                this.mesh = new THREE.Mesh(this.geometry, this.material);

                // Initial position of the sphere
                this.mesh.position.set(0, 0, 0);
            }

            // Method to add the sphere to the scene
            addToScene(scene) {
                scene.add(this.mesh);
            }

            // Method to update the sphere's position and rotation
            move() {
                this.mesh.rotation.x += 0.01;
                this.mesh.rotation.y += 0.01;
                this.mesh.position.x -= 0.02;
                this.mesh.position.y -= 0.01;
            }
        }

        // Create a new Sphere instance
        const sphere = new Sphere(10, 32, 32, 0xffff00);

        // Add a plane (flat surface) below the sphere
        const planeGeometry = new THREE.PlaneGeometry(50, 20);
        const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x999999, shininess: 30 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = - Math.PI / 2; // Rotate plane to be horizontal
        plane.position.y = -10; // Move it below the sphere
        plane.receiveShadow = true; // Enable the plane to receive shadows
        scene.add(plane);

        // Add sphere to the scene
        sphere.addToScene(scene);

        // Adding a spotlight
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(1, 15, 15);
        spotLight.target = sphere.mesh; // Ensure the spotlight targets the sphere
        spotLight.castShadow = true; // Enable the spotlight to cast shadows
        scene.add(spotLight);

        // Add a helper to visualize the camera's position
        const cameraHelper = new THREE.CameraHelper(spotLight.shadow.camera);
        scene.add(cameraHelper);

        // Optionally add an ambient light to prevent dark shadows
        var ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
        scene.add(ambientLight);

        // Create camera: fov 80, aspect ratio window size, near/far clipping planes
        var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Position the camera so it is in front of the sphere
        camera.position.z = 20;

        // Create renderer and set size to full window size
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadow mapping
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use soft shadows for smoother results
        document.body.appendChild(renderer.domElement);

        // Animation loop function
        function repeatMe() {
            // Update the sphere's rotation and position
            sphere.move();

            // Render the scene from the perspective of the camera
            renderer.render(scene, camera);

            // Call repeatMe again on the next frame
            requestAnimationFrame(repeatMe);
        }

        // Start the animation loop
        repeatMe();

        // Optional: Handle resizing so the canvas adjusts when window size changes
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>