<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title></title>
    <style type="text/css">
        h1 {
            text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <h1>Karol Uciecha</h1>
    <script type="text/javascript">
        //I used ChatGPT to help me with this assignment 
        // Scene creation
        var scene = new THREE.Scene();

        // Create renderer and set size to full window size
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadow mapping
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use soft shadows for smoother results
        document.body.appendChild(renderer.domElement);

        // Create camera: fov 80, aspect ratio window size, near/far clipping planes
        var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 50);
        camera.lookAt(0, 0, 0);

        // ===== SPHERE CLASS =====
        class Sphere {
            constructor(radius, widthSegments, heightSegments, color) {
                this.radius = radius;
                // Create geometry, material, and mesh for the sphere
                this.geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
                this.material = new THREE.MeshLambertMaterial({ color: color });
                this.mesh = new THREE.Mesh(this.geometry, this.material);

                // Enable shadows
                this.mesh.castShadow = true;

                // Initial position of the sphere
                this.mesh.position.set(0, 0, 0);

                // Motion physics
                this.velocityY = -1;       // current vertical velocity
                this.gravity = -0.01;     // downward acceleration
                this.bounceFactor = 0.9;  // energy retained after bounce

                // Rotation control
                this.rotationSpeed = 0.02;   // base rotation speed
                this.minVelocity = 0.002;    // threshold below which motion stops
                this.isMoving = true;
            }

            // Method to add the sphere to the scene
            addToScene(scene) {
                scene.add(this.mesh);
            }

            // Method to update the sphere's position and rotation
            move() {
                if (!this.isMoving) return;

                // Apply gravity
                this.velocityY += this.gravity;
                this.mesh.position.y += this.velocityY;

                // Bounce when hitting the plane
                const floorY = plane.position.y + this.radius;
                if (this.mesh.position.y <= floorY) {
                    this.mesh.position.y = floorY;
                    this.velocityY = -this.velocityY * this.bounceFactor;
                    this.rotationSpeed *= this.bounceFactor;
                }

                // Apply rotation (slows over time)
                this.mesh.rotation.x += this.rotationSpeed;
                this.mesh.rotation.y += this.rotationSpeed;
                
                // Stop motion when velocity & rotation are very small
                if (Math.abs(this.velocityY) < this.minVelocity && this.mesh.position.y <= floorY + 0.001) {
                this.isMoving = false;
                this.velocityY = 0;
                this.rotationSpeed = 0;
        }
    }
}

        // Create a new Sphere instance and add it to the scene
        const sphere = new Sphere(10, 32, 32, 0xffff00);
        sphere.addToScene(scene);

        // ===== PLANE (GROUND) =====
        const planeGeometry = new THREE.PlaneGeometry(200, 200);
        const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x999999, shininess: 30 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = - Math.PI / 2; // Rotate plane to be horizontal
        plane.position.y = -25; // Move it below the sphere
        plane.receiveShadow = true; // Enable the plane to receive shadows
        scene.add(plane);

        // ===== LIGHTING =====
        var spotLight = new THREE.SpotLight(0xffffff, 1.2);
        spotLight.position.set(30, 60, 25);
        spotLight.castShadow = true; // Enable the spotlight to cast shadows
        scene.add(spotLight);

        // Add a helper to visualize the camera's position
        const cameraHelper = new THREE.CameraHelper(spotLight.shadow.camera);
        scene.add(cameraHelper);

        // Optionally add an ambient light to prevent dark shadows
        var ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
        scene.add(ambientLight);

        // ===== ANIMATION LOOP =====
        function repeatMe() {
            // Update the sphere's rotation and position
            sphere.move();

            // Render the scene from the perspective of the camera
            renderer.render(scene, camera);

            // Call repeatMe again on the next frame
            requestAnimationFrame(repeatMe);
        }

        // Start the animation loop
        repeatMe();

        // Optional: Handle resizing so the canvas adjusts when window size changes
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>