<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title></title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #111; }
    h1 { text-align: center; color: white; position: absolute; width: 100%; top: 10px; z-index: 1; }
  </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <h1>Karol Uciecha</h1>
    <script type="text/javascript">

        // ===== SCENE SETUP =====
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadow mapping
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use soft shadows for smoother results
        document.body.appendChild(renderer.domElement);

        // Create camera: fov, aspect ratio window size, near/far clipping planes
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(60, 60, 80);
        camera.lookAt(0, 0, 0);

        // ===== LIGHTING =====
        var spotLight = new THREE.SpotLight(0xffffff, 1.2);
        spotLight.position.set(50, 100, 50);
        spotLight.castShadow = true; // Enable the spotlight to cast shadows
        scene.add(spotLight);

        // Add an ambient light to prevent dark shadows
        var ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
        scene.add(ambientLight);

        // ===== SPHERE CLASS =====
        class Sphere {
            constructor(radius, color, startX, startY, startZ) {
                this.radius = radius;
                // Create geometry, material, and mesh for the sphere
                this.geometry = new THREE.SphereGeometry(radius, 32, 32);
                this.material = new THREE.MeshLambertMaterial({ color: color });
                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.mesh.castShadow = true; // Enable shadow casting for the sphere
                this.mesh.position.set(startX, startY, startZ); // Initial position

                // Physics
                this.velocity = new THREE.Vector3(
                (Math.random() - 0.6), // x-axis velocity
                (Math.random() - 0.6), // y-axis velocity
                (Math.random() - 0.6) // z-axis velocity
                );
                this.bounceFactor = 0.9;
                this.rotationSpeed = 0.02;
            }

            // Method to add the sphere to the scene
            addToScene(scene) {
                scene.add(this.mesh);
            }

            // Method to update the sphere's position and rotation
            move() {
                // Update position based on velocity
                this.mesh.position.add(this.velocity);

                // Bounce inside cube boundaries
                // If cubeSize = 100 and radius = 10 → half = 50 - 10 = 40.
                // Sphere’s center cannot go beyond ±40 along any axis.
                const half = cubeSize / 2 - this.radius;

                // Loops through each axis (x, y, z) of the 3D space.
                ["x", "y", "z"].forEach(axis => {
                if (Math.abs(this.mesh.position[axis]) >= half) { // Example: if x = 41 and half = 40 → sphere hit the +X wall.
                    this.velocity[axis] = -this.velocity[axis] * this.bounceFactor; // Reverse velocity and apply bounce factor.
                    this.mesh.position[axis] = Math.sign(this.mesh.position[axis]) * half; // Ensures the sphere doesn’t go past the wall.
                }
                });

                // Apply rotation
                this.mesh.rotation.x += this.rotationSpeed;
                this.mesh.rotation.y += this.rotationSpeed;
    }
    
    // Detect and handle collision with another sphere
      checkCollision(other) {
        const posA = this.mesh.position;
        const posB = other.mesh.position; // mesh.position is a THREE.Vector3 object that holds the coordinates of the mesh’s origin in the scene.
        const dist = posA.distanceTo(posB); // Euclidean distance between the centers of the two spheres
        const minDist = this.radius + other.radius; // Minimum distance for a collision to occur

        if (dist < minDist) {
        // Reverse velocities along all axes
        ["x", "y", "z"].forEach(axis => {
            this.velocity[axis] = -this.velocity[axis] * this.bounceFactor;
            other.velocity[axis] = -other.velocity[axis] * other.bounceFactor;
        });

          // Slightly separate them so they don’t stick together
          // subVectors creates a new vector by subtracting posB from posA
          // normalize makes it a unit vector (length of 1) keeping only the direction
          const direction = new THREE.Vector3().subVectors(posA, posB).normalize();
          // Move each sphere away from the collision point along the direction vector
          posA.addScaledVector(direction, 1);
          posB.addScaledVector(direction, -1);
        }
      }
}

        // Create a new Spheres and add them to the scene
        const spheres = [
            new Sphere(10, 0xffff00, -25, 15, 0),
            new Sphere(10, 0x00ffcc, 25, 30, 0)
        ];

        spheres.forEach(s => s.addToScene(scene));

        // ===== TRANSPARENT CUBE =====
        const cubeSize = 100;
        const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
        const cubeMaterial = new THREE.MeshPhongMaterial({
        color: 0x6699ff,
        transparent: true,
        opacity: 0.2,
        side: THREE.BackSide // render inside of the cube
        });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.receiveShadow = true;
        scene.add(cube);

        // ===== ANIMATION LOOP =====
        function repeatMe() {
            spheres.forEach(s => s.move());

            // Collision check between all pairs
            for (let i = 0; i < spheres.length; i++) {
                for (let j = i + 1; j < spheres.length; j++) {
                    spheres[i].checkCollision(spheres[j]);
                }
            }

            renderer.render(scene, camera);

            requestAnimationFrame(repeatMe);
        }
        repeatMe();

        // Optional: Handle resizing so the canvas adjusts when window size changes
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>