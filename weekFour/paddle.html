<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
    <title>Canvas</title>
    <style type="text/css">
      body {
        background-color: white;
      }
      
      canvas {
        border: 1px solid black;
      }

      h1 {
        text-align: center;
      }
    </style>
  </head>
  <body>
    <h1>Karol Uciecha: G00436758</h1>
    <canvas id="canvas" width="500" height="500"></canvas>
    <h1 id="touchdown"></h1>
    <script type="text/javascript">
      // Canvas dimensions
      const canvasHeight = 500;
      const canvasWidth = 500;

      // Get canvas and drawing context
      let canvas = document.getElementById("canvas");
      let ctx = canvas.getContext("2d");

      // ---------------- MATCHBALL CLASS ----------------
      class MatchBall {
        constructor(xPosition, yPosition, radius, xSpeed, ySpeed, rSpeed, gravity = 0.5, friction = 0.99, rotationFriction = 0.99) {
          this.xPosition = xPosition;
          this.yPosition = yPosition;
          this.radius = radius;
          this.xSpeed = xSpeed;
          this.ySpeed = ySpeed;
          this.rSpeed = rSpeed;
          this.gravity = gravity;
          this.friction = friction;
          this.rotationFriction = rotationFriction;
        }

        // Draw the MatchBall (circle outline)
        draw() {
          ctx.beginPath();
          ctx.fillStyle = "blue";
          ctx.arc(this.xPosition, this.yPosition, this.radius, 0, 2 * Math.PI);
          ctx.fill();
        }

        // Move the MatchBall and check for wall collisions
        move() {
          this.ySpeed += this.gravity;
          this.xSpeed *= this.friction;
          this.rSpeed *= this.rotationFriction;

          this.xPosition += this.xSpeed;
          this.yPosition += this.ySpeed;

          // Bounce off bottom
          if (this.yPosition >= canvasHeight - this.radius) {
            this.yPosition = canvasHeight - this.radius;
            this.ySpeed *= -(this.friction);
            this.rSpeed *= -(this.rotationFriction); 
          }

          // Bounce off top
          if (this.yPosition <= this.radius) {
            this.yPosition = this.radius;
            this.ySpeed *= -(this.friction);
            this.rSpeed *= -(this.rotationFriction);
          }

          // Bounce off right
          if (this.xPosition >= canvasWidth - this.radius) {
            this.xPosition = canvasWidth - this.radius;
            this.xSpeed *= -(this.friction);
            this.rSpeed *= -(this.rotationFriction); 
          }

          // Bounce off left
          if (this.xPosition <= this.radius) {
            this.xPosition = this.radius;
            this.xSpeed *= -(this.friction);
            this.rSpeed *= -(this.rotationFriction); 
          }

          // Stop very slow movements
          if (Math.abs(this.xSpeed) < 0.01) this.xSpeed = 0;
          if (Math.abs(this.ySpeed) < 0.01) this.ySpeed = 0;
          if (Math.abs(this.rSpeed) < 0.01) this.rSpeed = 0;

          this.rotate();
        }

        // Rotate MatchBall
        rotate(acceleration = 0) {
          if (acceleration > 0) this.rSpeed *= 1.1;
          else if (acceleration < 0) this.rSpeed *= 0.9;
          this.rotation += this.rSpeed * 0.05;
      }
    }

      // ---------------- PADDLEBALL CLASS ----------------
      class PaddleBall {
        constructor(keyboardPaddle = false) {
          this.wallOffset = 40;
          this.radius = 20;
          if (keyboardPaddle) this.xPosition = canvasWidth - this.wallOffset;
          else this.xPosition = this.wallOffset;
          this.yPosition = canvasHeight / 2;
          this.keyboardPaddle = keyboardPaddle;
        }
        
        // Draw the paddleBall
        draw() {
          ctx.beginPath();
          if (this.keyboardPaddle) ctx.fillStyle = "green";
          else ctx.fillStyle = "red"
          ctx.arc(this.xPosition, this.yPosition, this.radius, 0, 2 * Math.PI);
          ctx.fill();
        }

        // Move paddleBall with keyboard
        keyboardMove(pixels, direction = false) {
          if (direction && this.keyboardPaddle && (this.yPosition - this.radius > 0)) this.yPosition -= pixels;
          // Prevent paddle from going out of bounds
          else if (direction == false && this.keyboardPaddle && (this.yPosition + this.radius < canvasHeight)) this.yPosition += pixels;
        }

        // Move paddleBall with mouse
        mouseMove(pixels, mousePosition) 
        {
          // Move paddleBall towards mouse position
          if ((this.yPosition - this.radius > mousePosition) && (this.yPosition - this.radius > 0)) this.yPosition -= pixels;
          // Prevent paddleBall from going out of bounds
          else if (((this.yPosition - this.radius) < mousePosition) && this.yPosition + this.radius < canvasWidth) this.yPosition += pixels;
        }
      }

      // ---------------- CREATE OBJECTS ----------------
      const ball = new MatchBall(50, 100, 10, 10 * Math.random(), 10 * Math.random(), 10 * Math.random());
      const paddleRight = new PaddleBall(true);
      const paddleLeft = new PaddleBall(false);


      // ---------------- ANIMATION LOOP ----------------
      function repeatme() {
        // Clear screen
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        // Draw + Move objects
        ball.draw();
        ball.move();
        paddleRight.draw();
        paddleLeft.draw();

        collisionDetection();

        // Loop animation
        window.requestAnimationFrame(repeatme);
      }

      function collisionDetection() {
        var distanceRight = Math.sqrt(Math.pow((paddleRight.xPosition + paddleRight.radius) - (ball.xPosition + ball.radius), 2) + Math.pow((paddleRight.yPosition + paddleRight.radius) - (ball.yPosition + ball.radius), 2));
        var distanceLeft =  Math.sqrt(Math.pow((paddleLeft.xPosition + paddleLeft.radius) - (ball.xPosition + ball.radius), 2) + Math.pow((paddleLeft.yPosition + paddleLeft.radius) - (ball.yPosition + ball.radius), 2));
        console.log(distanceRight + ", " + distanceLeft);
        if (distanceLeft == 0) {}
        else if (distanceRight == 0) {}
      }

      //keypresses with jQuery
		  $(document.body).on('keydown', function(e) {
        console.log(e.which);
        switch (e.which) {
          // key code for O (minus rotation speed)
          case 79:
            pacman.rotate(-1);
            break;
          // key code for P (plus rotation speed)
          case 80:
            pacman.rotate(1);
            break;
          // key code for up arrow
          case 38:
            paddleRight.keyboardMove(5, true);
            break;
            // key code for down arrow
          case 40:
            paddleRight.keyboardMove(5, false);
            break;
          }
        });

        canvas.addEventListener("mousemove", function(event) {
        // Locating the mouse click on the canvas
        yPosition = event.clientY - canvas.offsetTop;
        paddleLeft.mouseMove(5, yPosition);
      });

      // Start animation
      repeatme();
    </script>
  </body>
</html>
