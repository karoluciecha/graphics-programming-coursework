<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
    <title>Canvas</title>
    <style type="text/css">
    body {
      background-color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
    }

    canvas {
      border: 1px solid black;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    h1 {
      text-align: center;
      margin: 0;
    }

    #redScore {
      color: red;
    }

    #greenScore {
      color: green;
    }
    </style>
  </head>
  <body>
    <h1>Karol Uciecha: G00436758</h1>
    <canvas id="canvas" width="500" height="500"></canvas>
    <h1>Score: <span id="touchdown"></span></h1>
    <h1><span id="redScore">0</span> Â¦ <span id="greenScore">0</span></h1>
    <script type="text/javascript">
      // Canvas dimensions
      const canvasHeight = 500;
      const canvasWidth = 500;

      // Get canvas and drawing context
      let canvas = document.getElementById("canvas");
      let ctx = canvas.getContext("2d");

// ---------------- MATCHBALL CLASS ----------------
class MatchBall {
  constructor(xPosition, yPosition, radius, xSpeed, ySpeed, rSpeed, gravity = 0, friction = 1, rotationFriction = 1) {
    this.xPosition = xPosition;
    this.yPosition = yPosition;
    this.radius = radius;
    this.xSpeed = xSpeed;
    this.ySpeed = ySpeed;
    this.rSpeed = rSpeed;
    this.gravity = gravity;  // 0 for no gravity, >0 for gravity
    this.friction = friction;  // 1 for no friction, <1 for friction
    this.rotationFriction = rotationFriction; // 1 for no friction, <1 for friction
    this.rotation = 0;  // Initial rotation angle (in radians)
  }

  // Draw the MatchBall
  draw() {
    ctx.beginPath();
    ctx.fillStyle = "blue";
    ctx.arc(this.xPosition, this.yPosition, this.radius, 0, 2 * Math.PI);
    ctx.fill();
  }

  // Move the MatchBall and check for wall collisions
  move() {
    this.ySpeed += this.gravity;  // Apply gravity
    this.xSpeed *= this.friction;  // Apply friction to x speed
    this.rSpeed *= this.rotationFriction;  // Apply rotation friction

    this.xPosition += this.xSpeed;  // Update x position
    this.yPosition += this.ySpeed;  // Update y position

    // Bounce off bottom
    if (this.yPosition >= canvasHeight - this.radius) {
      this.yPosition = canvasHeight - this.radius;
      this.ySpeed *= -(this.friction);  // Reverse speed with friction
      this.rSpeed *= -(this.rotationFriction);  // Reverse rotation speed with friction
    }

    // Bounce off top
    if (this.yPosition <= this.radius) {
      this.yPosition = this.radius;
      this.ySpeed *= -(this.friction);  // Reverse speed with friction
      this.rSpeed *= -(this.rotationFriction);  // Reverse rotation speed with friction
    }

    // Bounce off right
    if (this.xPosition >= canvasWidth - this.radius) {
      this.xPosition = canvasWidth - this.radius;
      this.xSpeed *= -(this.friction);  // Reverse speed with friction
      this.rSpeed *= -(this.rotationFriction);  // Reverse rotation speed with friction
      scoreCalculation(-1, "green"); // Deduct point for right wall hit
    }

    // Bounce off left
    if (this.xPosition <= this.radius) {
      this.xPosition = this.radius;
      this.xSpeed *= -(this.friction);  // Reverse speed with friction
      this.rSpeed *= -(this.rotationFriction);  // Reverse rotation speed with friction
      scoreCalculation(-1, "red"); // Deduct point for left wall hit
    }

    // Stop very slow movements
    if (Math.abs(this.xSpeed) < 0.01) this.xSpeed = 0;
    if (Math.abs(this.ySpeed) < 0.01) this.ySpeed = 0;
    if (Math.abs(this.rSpeed) < 0.01) this.rSpeed = 0;

    this.rotate();  // Rotate ball based on current speed
  }

  // Rotate the MatchBall
  rotate(acceleration = 0) {
    if (acceleration > 0) this.rSpeed *= 1.1;  // Increase rotation speed
    else if (acceleration < 0) this.rSpeed *= 0.9;  // Decrease rotation speed
    this.rotation += this.rSpeed * 0.05;  // Update rotation angle
  }
}

      // ---------------- PADDLEBALL CLASS ----------------
      class PaddleBall {
        constructor(keyboardPaddle = false) {
          this.wallOffset = 40;
          this.radius = 20;
          if (keyboardPaddle) this.xPosition = canvasWidth - this.wallOffset;
          else this.xPosition = this.wallOffset;
          this.yPosition = canvasHeight / 2;
          this.keyboardPaddle = keyboardPaddle;
        }
        
        // Draw the paddleBall
        draw() {
          ctx.beginPath();
          if (this.keyboardPaddle) ctx.fillStyle = "green";
          else ctx.fillStyle = "red"
          ctx.arc(this.xPosition, this.yPosition, this.radius, 0, 2 * Math.PI);
          ctx.fill();
        }

        // Move paddleBall with keyboard
        keyboardMove(pixels, direction = false) {
          if (direction && this.keyboardPaddle && (this.yPosition - this.radius > 0)) this.yPosition -= pixels;
          // Prevent paddle from going out of bounds
          else if (direction == false && this.keyboardPaddle && (this.yPosition + this.radius < canvasHeight)) this.yPosition += pixels;
        }

        // Move paddleBall with mouse
        mouseMove(pixels, mousePosition) 
        {
          // Move paddleBall towards mouse position
          if ((this.yPosition - this.radius > mousePosition) && (this.yPosition - this.radius > 0)) this.yPosition -= pixels;
          // Prevent paddleBall from going out of bounds
          else if (((this.yPosition - this.radius) < mousePosition) && this.yPosition + this.radius < canvasWidth) this.yPosition += pixels;
        }
      }

      // ---------------- CREATE OBJECTS ----------------
      const ball = new MatchBall(50, 100, 10, 10 * Math.random(), 10 * Math.random(), 10 * Math.random());
      const paddleRight = new PaddleBall(true);
      const paddleLeft = new PaddleBall(false);


      // ---------------- ANIMATION LOOP ----------------
      function repeatme() {
        // Clear screen
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        // Draw + Move objects
        ball.draw();
        ball.move();
        paddleRight.draw();
        paddleLeft.draw();

        collisionDetection();

        // Loop animation
        window.requestAnimationFrame(repeatme);
      }

function collisionDetection() {
  // Calculate the distance between the ball and each paddle's center
  var distanceRight = Math.sqrt(Math.pow((paddleRight.xPosition - ball.xPosition), 2) + Math.pow((paddleRight.yPosition - ball.yPosition), 2));
  var distanceLeft = Math.sqrt(Math.pow((paddleLeft.xPosition - ball.xPosition), 2) + Math.pow((paddleLeft.yPosition - ball.yPosition), 2));

  // Check if the distance is less than the sum of the radii
  if (distanceLeft <= (paddleLeft.radius + ball.radius)) scoreCalculation(1, "red");
  else if (distanceRight <= (paddleRight.radius + ball.radius)) scoreCalculation(1, "green");
}

function scoreCalculation(type, side) {

  if (type == 1 && side == "red") {
    document.getElementById('redScore').innerText = parseInt(document.getElementById('redScore').innerText) + 1;
    
    // Show the message for one second
    document.getElementById('touchdown').innerText = "red scores!";
    setTimeout(() => {
      document.getElementById('touchdown').innerText = "";
    }, 1000);
  }

  if (type == 1 && side == "green") {
    document.getElementById('greenScore').innerText = parseInt(document.getElementById('greenScore').innerText) + 1;

    // Show the message for one second
    document.getElementById('touchdown').innerText = "green scores!";
    setTimeout(() => {
      document.getElementById('touchdown').innerText = "";
    }, 1000);
  }

  if (type == -1 && side == "red") {
    document.getElementById('redScore').innerText = parseInt(document.getElementById('redScore').innerText) - 1;
    
    // Show the message for one second
    document.getElementById('touchdown').innerText = "red loses a point!";
    setTimeout(() => {
      document.getElementById('touchdown').innerText = "";
    }, 1000);
  }

  if (type == -1 && side == "green") {
    document.getElementById('greenScore').innerText = parseInt(document.getElementById('greenScore').innerText) - 1;

    // Show the message for one second
    document.getElementById('touchdown').innerText = "green loses a point!";
    setTimeout(() => {
      document.getElementById('touchdown').innerText = "";
    }, 1000);
  }

}

      //keypresses with jQuery
		  $(document.body).on('keydown', function(e) {
        console.log(e.which);
        switch (e.which) {
          // key code for O (minus rotation speed)
          case 79:
            pacman.rotate(-1);
            break;
          // key code for P (plus rotation speed)
          case 80:
            pacman.rotate(1);
            break;
          // key code for up arrow
          case 38:
            paddleRight.keyboardMove(5, true);
            break;
            // key code for down arrow
          case 40:
            paddleRight.keyboardMove(5, false);
            break;
          }
        });

        canvas.addEventListener("mousemove", function(event) {
        // Locating the mouse click on the canvas
        yPosition = event.clientY - canvas.offsetTop;
        paddleLeft.mouseMove(5, yPosition);
      });

      // Start animation
      repeatme();
    </script>
  </body>
</html>
